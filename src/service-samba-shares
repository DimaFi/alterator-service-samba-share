#!/bin/bash

# Chrony service provision
# Tool for provision samba share service
#
# Copyright (C) 2025 Filippenko Dmitry <dmitfilippenko@yandex.ru>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# shellcheck disable=SC2034
# shellcheck disable=SC1091
# shellcheck disable=SC2086
# shellcheck disable=SC2317
# shellcheck disable=SC3037

export SYSTEMD_PAGER=
export LC_ALL=C
set -euo pipefail



. shell-getopt || true
. shell-ini-config || true

PROG_NAME="${0##*/}"

show_usage() {
    cat <<EOF
Usage: $PROG_NAME [OPTIONS]

Tool for managing Samba shares.

Options:
  -h, --help          Show this help message and exit.
  -v, --version       Show program's version number and exit.
  --create            Create a new Samba share (requires JSON input).
  --delete            Delete an existing Samba share (requires JSON input).
  --update            Update an existing Samba share (requires JSON input).
  --deploy            Deploy Samba services and configure initial state.
  --undeploy          Disable Samba services and restore initial config.
  --backup            Backup Samba configuration (optional name via JSON).
  --restore           Restore Samba configuration from backup (optional name).
  --start             Start Samba service.
  --stop              Stop Samba service.
  --status            Show status of Samba services and shares.

Input for create, delete, update, backup, restore, deploy, and undeploy
operations is expected as a JSON object via standard input.

EOF
    exit 0
}

# If the --help or -h flag is passed, print help and exit.
[[ "${1:-}" == "--help" || "${1:-}" == "-h" ]] && show_usage


LOG_FILE="/var/log/samba-shares.log"

log() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] [PID:$$] $1" >> "$LOG_FILE"
}

error() {
  log "ERROR: $1"
  echo "{\"status\": \"error\", \"message\": \"$1\"}"
  release_lock
  exit 1
} 

get_samba_shares() {
  testparm -s 2>/dev/null | awk '
    BEGIN {
      print "["
      first = 1
    }

    /^\[.*\]$/ {
      if (share != "" && path != "") {
        if (!first) printf(",\n"); else first = 0

        access_type = "ro"
        if (tolower(writable) == "yes" || tolower(readonly) == "no") access_type = "rw"

        printf("  {\"share_name\":\"%s\",\"share_path\":\"%s\",\"access_type\":\"%s\",\"access_user\":\"\",\"enabled\":true,\"allowed_users\":\"%s\"}", share, path, access_type, allowed_users)
      }

      share = substr($0, 2, length($0) - 2)
      path = ""; writable = ""; readonly = ""; allowed_users = ""
      next
    }

    /^[[:space:]]*path[[:space:]]*=/ {
      sub(/^[[:space:]]*path[[:space:]]*=[[:space:]]*/, "")
      path = $0
      next
    }

    /^[[:space:]]*writable[[:space:]]*=/ {
      sub(/^[[:space:]]*writable[[:space:]]*=[[:space:]]*/, "")
      writable = $0
      next
    }

    /^[[:space:]]*read only[[:space:]]*=/ {
      sub(/^[[:space:]]*read only[[:space:]]*=[[:space:]]*/, "")
      readonly = $0
      next
    }

    /^[[:space:]]*valid users[[:space:]]*=/ {
      sub(/^[[:space:]]*valid users[[:space:]]*=[[:space:]]*/, "")
      allowed_users = $0
      next
    }

    /^\s*$/ {
      if (share != "" && path != "") {
        if (!first) printf(",\n"); else first = 0

        access_type = "ro"
        if (tolower(writable) == "yes" || tolower(readonly) == "no") access_type = "rw"

        printf("  {\"share_name\":\"%s\",\"share_path\":\"%s\",\"access_type\":\"%s\",\"access_user\":\"\",\"enabled\":true,\"allowed_users\":\"%s\"}", share, path, access_type, allowed_users)
      }

      share = ""; path = ""; writable = ""; readonly = ""; allowed_users = ""
    }

    END {
      if (share != "" && path != "") {
        if (!first) printf(",\n")

        access_type = "ro"
        if (tolower(writable) == "yes" || tolower(readonly) == "no") access_type = "rw"

        printf("  {\"share_name\":\"%s\",\"share_path\":\"%s\",\"access_type\":\"%s\",\"access_user\":\"\",\"enabled\":true,\"allowed_users\":\"%s\"}", share, path, access_type, allowed_users)
      }

      print "\n]"
    }
  ' 
}

get_fs_owner() {
  local p="$1"
  [ -e "$p" ] || { echo ""; return; }
  if command -v getfacl >/dev/null 2>&1; then
    getfacl -p --absolute-names "$p" 2>/dev/null | awk -F': ' '/^# owner:/{print $2; exit}'
  else
    stat -c '%U' "$p" 2>/dev/null || echo ""
  fi
}

augment_shares_with_owner() {
  local json="$1"
  echo "$json" | jq -c '.[]' | while read -r item; do
    local path owner
    path=$(echo "$item" | jq -r '.share_path')
    owner=$(get_fs_owner "$path")
    if [ -n "$owner" ]; then
      echo "$item" | jq --arg owner "$owner" '. + {access_user: $owner}'
    else
      echo "$item"
    fi
  done | jq -s '.'
}

get_share_current() {
  local name="$1"
  local cur
  cur=$(augment_shares_with_owner "$(get_samba_shares)" | jq -c --arg n "$name" '.[] | select(.share_name==$n)')
  [ -z "$cur" ] && error "Share not found: $name"
  echo "$cur"
}

remove_share_section() {
  local share_name="$1"
  local conf="/etc/samba/smb.conf"
  local TMP
  TMP=$(mktemp) || error "Cannot create temp file"

  awk -v target="$share_name" '
    function trim(s){ gsub(/^[ \t]+|[ \t]+$/, "", s); return s }
    BEGIN { insec=0 }
    /^\[.*\]$/ {
      # встретили заголовок секции
      hdr = substr($0, 2, length($0)-2);
      hdr = trim(hdr);
      # если до этого были внутри целевой — выходим из неё
      if (insec) { insec=0 }
      # если это целевая — включаем пропуск
      if (hdr == target) { insec=1; next }
    }
    # если в целевой секции — пропускаем строки
    insec { next }
    # иначе печатаем как есть
    { print }
  ' "$conf" > "$TMP" || { rm -f "$TMP"; error "Failed to edit smb.conf"; }

  # Валидация и применение
  testparm -s "$TMP" >/dev/null 2>&1 || { rm -f "$TMP"; error "Configuration error after section removal"; }
  mv "$TMP" "$conf" || { rm -f "$TMP"; error "Failed to update smb.conf"; }
  chmod 0644 "$conf" || true
}



# ======= FUNC FOR ALL ACTION =======

create_share() {
  local share_name="$1"
  local share_path="$2"
  local access_user="$3"
  local access_type="$4"
  local allowed_users="$5"

  log "Create shared folder: $share_name on path '$share_path'"

  # Checking required parameters
  if [ -z "$share_name" ] || [ -z "$share_path" ] || [ -z "$access_user" ] || [ -z "$access_type" ]; then
    error "Required parameters for creation are not set."
  fi

  # Check the user
  if ! id "$access_user" >/dev/null 2>&1; then
      error "User $access_user does not exist"
  fi
  local user_group
  user_group=$(id -gn "$access_user")

  # Creating a folder with quotes
  mkdir -p "$share_path" || error "Couldn't create folder '$share_path'"
  chown -R "$access_user:$user_group" "$share_path" || error "Couldn't set owner $access_user:$user_group"

  # Folder permissions
  if [ "$access_type" == "rw" ]; then
    chmod 2770 "$share_path" || error "Couldn't set permissions 2770"
  else
    chmod 2750 "$share_path" || error "Couldn't set permissions 2750"
  fi

  # Clearing ACLs
  command -v setfacl >/dev/null 2>&1 && setfacl -b "$share_path" 2>/dev/null || true

  # Checking the existence of a share in smb.conf
  grep -q "^\[$share_name\]" /etc/samba/smb.conf && error "Shared folder [$share_name] already exists"

  # Generate a list of valid users
  local valid_users="$access_user"
  [ -n "$allowed_users" ] && [ "$allowed_users" != "null" ] && valid_users="$access_user,$allowed_users"

  # Add an entry to smb.conf
  local TEMP_FILE
  TEMP_FILE=$(mktemp)
  cp /etc/samba/smb.conf "$TEMP_FILE"

  tail -c1 /etc/samba/smb.conf | read -r _ || echo >> /etc/samba/smb.conf

  cat <<EOF >> "$TEMP_FILE"

[$share_name]
   path = $share_path
   browsable = yes
   writable = $( [ "$access_type" == "rw" ] && echo yes || echo no )
   guest ok = no
   valid users = $valid_users
EOF

  testparm -s "$TEMP_FILE" >/dev/null || { rm -f "$TEMP_FILE"; error "Configuration error in smb.conf"; }
  mv "$TEMP_FILE" /etc/samba/smb.conf
  chmod 644 /etc/samba/smb.conf

  log "Running: systemctl restart smb.service"
  timeout 15 systemctl restart smb.service >> "$LOG_FILE" 2>&1 || error "Couldn't restart smb.service"

  local deployed started
  systemctl is-active smb.service >/dev/null 2>&1 && deployed=true || deployed=false
  systemctl is-active smb.service >/dev/null 2>&1 && started=true || started=false

  local shares_json
  shares_json=$(augment_shares_with_owner "$(get_samba_shares)")

  echo "{
    \"status\": \"created\",
    \"deployed\": $deployed,
    \"started\": $started,
    \"shares\": $shares_json,
    \"message\": {
      \"ru\": \"Общая папка успешно создана\",
      \"en\": \"Shared folder successfully created\"
    }
  }"
}

delete_share() {
  local share_name="$1"
  [ -z "$share_name" ] && error "Required parameters for deletion are not set"

  # Normalize the name: remove the spaces at the edges
  share_name="$(printf '%s' "$share_name" | awk '{$1=$1; print}')"
  log "Delete request for share: '$share_name'"

  # check the existence of the balls through testparm -s ---
  # List of all sections except [global]
  local exists
  exists=$(testparm -s 2>/dev/null \
    | awk '
        /^\[.*\]$/ {
          name=substr($0,2,length($0)-2);
          gsub(/^[ \t]+|[ \t]+$/, "", name);
          if (tolower(name)!="global") print name;
        }' \
    | awk -v tgt="$share_name" 'BEGIN{f=0} { if($0==tgt) f=1 } END{ print f }')

  if [ "$exists" != "1" ]; then
    error "Shared folder [$share_name] not found"
  fi

  # Delete the section as a block, resistant to the absence of empty lines
  local TMP
  TMP=$(mktemp) || error "Cannot create temp file"

  awk -v target="$share_name" '
    function trim(s){ gsub(/^[ \t]+|[ \t]+$/, "", s); return s }
    BEGIN { insec=0 }
    /^\[.*\]$/ {
      # met the section title
      hdr = substr($0, 2, length($0)-2);
      hdr = trim(hdr);
      # if you were inside the target area before, get out of it
      if (insec) { insec=0 }
      # if this is the target, enable the pass
      if (hdr == target) { insec=1; next }
    }
    # if it is in the target section, skip the lines
    insec { next }
    # otherwise, we print it as it is.
    { print }
  ' /etc/samba/smb.conf > "$TMP" || { rm -f "$TMP"; error "Failed to edit smb.conf"; }

  # Validate and apply
  if ! testparm -s "$TMP" >/dev/null 2>&1; then
    rm -f "$TMP"
    error "Configuration error after deletion (testparm failed)"
  fi

  mv "$TMP" /etc/samba/smb.conf || { rm -f "$TMP"; error "Failed to update smb.conf"; }
  chmod 644 /etc/samba/smb.conf || true

  # Restart and reply
  log "Restarting smb.service after delete"
  timeout 15 systemctl restart smb.service >> "$LOG_FILE" 2>&1 || error "Couldn't restart smb.service"

  local shares_json
  shares_json=$(augment_shares_with_owner "$(get_samba_shares)")

  echo "{
    \"status\": \"deleted\",
    \"deployed\": $(systemctl is-active smb.service >/dev/null && echo true || echo false),
    \"started\":  $(systemctl is-active smb.service >/dev/null && echo true || echo false),
    \"shares\": $shares_json,
    \"message\": {
      \"ru\": \"Общая папка успешно удалена из конфигурации\",
      \"en\": \"Shared folder successfully removed from configuration\"
    }
  }"
}

update_share() {
  local share_name="$1"
  local share_path="$2"
  local access_user="$3"
  local access_type="$4"
  local allowed_users="$5"

  [ -z "$share_name" ] && error "share_name is required for update"

  # Current values from the configuration/FS
  local cur
  cur=$(get_share_current "$share_name")

  # We'll substitute everything that didn't arrive
  [ -z "$share_path" ]   && share_path=$(echo "$cur" | jq -r '.share_path')
  [ -z "$access_user" ]  && access_user=$(echo "$cur" | jq -r '.access_user // empty')
  [ -z "$access_type" ]  && access_type=$(echo "$cur" | jq -r '.access_type // "ro"')
  [ -z "$allowed_users" ]&& allowed_users=$(echo "$cur" | jq -r '.allowed_users // empty')

  # Validation of totals
  [ -z "$share_path" ]  && error "share_path unresolved"
  [ -z "$access_type" ] && error "access_type unresolved"
  if [ "$access_type" != "guest" ]; then
    [ -z "$access_user" ] && error "access_user is required for non-guest share"
  fi

  # Re-creating the section 
  remove_share_section "$share_name"

  mkdir -p "$share_path"
  if [ "$access_type" = "guest" ]; then
    chmod 0777 "$share_path"
    chown nobody:nogroup "$share_path"
  else
    id "$access_user" >/dev/null 2>&1 || useradd -m "$access_user"
    local user_group
    user_group=$(id -gn "$access_user")
    chown -R "$access_user":"$user_group" "$share_path"
    chmod 2770 "$share_path"
  fi

  local valid_users
  if [ "$access_type" = "guest" ]; then
    valid_users=""
  else
    valid_users="$access_user"
    [ -n "$allowed_users" ] && valid_users="$access_user,$allowed_users"
  fi

  tail -c1 /etc/samba/smb.conf | read -r _ || echo >> /etc/samba/smb.conf

  {
    echo
    echo "[$share_name]"
    echo "   path = $share_path"
    echo "   browsable = yes"
    if [ "$access_type" = "guest" ]; then
      echo "   writable = yes"
      echo "   guest ok = yes"
    else
      echo "   writable = $( [ "$access_type" = "rw" ] && echo yes || echo no )"
      echo "   guest ok = no"
      echo "   valid users = $valid_users"
    fi
  } >> /etc/samba/smb.conf

  testparm -s /etc/samba/smb.conf >/dev/null || error "Configuration error in smb.conf"
  systemctl restart smb.service >> "$LOG_FILE" 2>&1 || error "Couldn't restart smb.service"

  local shares_json
  shares_json=$(augment_shares_with_owner "$(get_samba_shares)")
  echo "{
    \"status\": \"updated\",
    \"shares\": $shares_json,
    \"deployed\": $(systemctl is-active smb.service >/dev/null && echo true || echo false),
    \"started\": $(systemctl is-active smb.service >/dev/null && echo true || echo false),
    \"message\": {
      \"ru\": \"Общая папка успешно обновлена\",
      \"en\": \"Shared folder successfully updated\"
    }
  }"
}


deploy_samba_share() {
  command -v smbd >/dev/null || error "Samba not installed"

  # Save the original only once
  local original="/var/lib/alterator/service/service-samba-share/config-backup/smb-original.conf"
  if [ ! -f "$original" ]; then
    mkdir -p /var/lib/alterator/service/service-samba-share/config-backup || error "Failed to create backup directory"
    cp /etc/samba/smb.conf "$original" || error "Couldn't save the original one smb.conf"
  fi

  systemctl enable --now smb nmb &>> "$LOG_FILE" || error "Failed to activate services Samba"
  ! systemctl is-active smb nmb >/dev/null && error "The services have not moved to an active state"

  if command -v alterator-announce >/dev/null 2>&1; then
    alterator-announce "samba_shares" "deployed" || true
  fi

  echo '{
    "status": "deployed",
    "state": "deployed",
    "deployed": true,
    "started": true,
    "services": {
      "smb": "active",
      "nmb": "active"
    },
    "message": {
      "ru": "Samba успешно развернут. Теперь вы можете предоставить общий доступ к папкам через меню «Настройка» в alt-services.",
      "en": "Samba successfully deployed. You can now share folders through the 'Settings' menu in alt-services."
    }
  }'
}

undeploy_samba_share() {
  log "Executing: systemctl stop smb.service"
  if ! timeout 15 systemctl stop smb.service >> "$LOG_FILE" 2>&1; then
    error "Failed to execute stop for smb.service"
  fi

  log "Executing: systemctl disable smb.service"
  if ! timeout 15 systemctl disable smb.service >> "$LOG_FILE" 2>&1; then
    error "Failed to execute disable for smb.service"
  fi

  log "Executing: systemctl stop nmb.service"
  if ! timeout 15 systemctl stop nmb.service >> "$LOG_FILE" 2>&1; then
    error "Failed to execute stop for nmb.service"
  fi

  log "Executing: systemctl disable nmb.service"
  if ! timeout 15 systemctl disable nmb.service >> "$LOG_FILE" 2>&1; then
    error "Failed to execute disable for nmb.service"
  fi

  local original="/var/lib/alterator/service/service-samba-share/config-backup/smb-original.conf"
  if [ -f "$original" ]; then
    cp "$original" /etc/samba/smb.conf || error "Failed to restore original smb.conf"
  else
    log "Original smb.conf not found, restore skipped"
  fi

  echo '{
    "status": "undeployed",
    "deployed": true,
    "started": true,
    "message": {
      "ru": "Samba отключен, smb.conf восстановлен",
      "en": "Samba disabled, smb.conf restored"
    }
  }'
}

start_samba_share() {
  log "Running: systemctl start smb.service"
  if ! timeout 15 systemctl start smb.service >> "$LOG_FILE" 2>&1; then
    error "Failed to run smb.service"
  fi

  local shares_json
  shares_json=$(augment_shares_with_owner "$(get_samba_shares)")
  echo "{
    \"status\": \"started\",
    \"shares\": $shares_json,
    \"message\": {
      \"ru\": \"Служба Samba запущена\",
      \"en\": \"Samba service started\"
    }
  }"
}

stop_samba_share() {
  log "Running: systemctl stop smb.service"
  if ! timeout 15 systemctl stop smb.service >> "$LOG_FILE" 2>&1; then
    error "Failed to stop smb.service"
  fi

  local shares_json
  shares_json=$(augment_shares_with_owner "$(get_samba_shares)")
  echo "{
    \"status\": \"stopped\",
    \"shares\": $shares_json,
    \"message\": {
      \"ru\": \"Служба Samba остановлена\",
      \"en\": \"Samba service stopped\"
    }
  }"
}

status_samba_share() {
  local smb_status 
  local nmb_status 
  local state 
  local exit_code 
  local shares_json

  smb_status=$(systemctl is-active smb.service)
  nmb_status=$(systemctl is-active nmb.service)

  if [ "$smb_status" == "active" ] && [ "$nmb_status" == "active" ]; then
    state="deployed"; exit_code=128
  elif [ "$smb_status" == "active" ] || [ "$nmb_status" == "active" ]; then
    state="deployed"; exit_code=127
  else
    state="undeployed"; exit_code=0
  fi

  shares_json=$(augment_shares_with_owner "$(get_samba_shares)")

  echo "{
    \"status\": \"$state\",
    \"state\": \"$state\",
    \"services\": {
      \"smb\": \"$smb_status\",
      \"nmb\": \"$nmb_status\"
    },
    \"shares\": $shares_json,
    \"message\": {
      \"ru\": \"Состояние Samba: $state\",
      \"en\": \"Samba state: $state\"
    }
  }"

  exit $exit_code
}

backup_all() {
  local backup_name="$1"

  # Backup storage directories (left the same as before)
  local base_dir="/var/lib/alterator/service/service-samba-share"
  local config_dir="$base_dir/config-backup"
  local data_dir="$base_dir/data-backup"

  mkdir -p "$config_dir" "$data_dir" || error "Failed to create backup directories"

  # Backup name
  if [ -z "$backup_name" ] || [ "$backup_name" = "null" ]; then
    local ts
    ts=$(date '+%Y%m%d-%H%M%S')
    backup_name="smb-$ts"
  fi

  local config_file="$config_dir/${backup_name}.conf"
  local data_file="$data_dir/${backup_name}.tar.gz"

  # Configuration backup — always
  if ! cp /etc/samba/smb.conf "$config_file"; then
    error "Failed to create config backup"
  fi

  # Collecting balloon paths from the current configuration
  # - neat, one line at a time, unique
  # - filter out empty and non-existent ones
  local list
  list=$(mktemp) || error "Cannot create temp file"
  get_samba_shares \
    | jq -r '.[].share_path' \
    | sed '/^$/d' \
    | sort -u \
    | while IFS= read -r p; do
        # backup only the actual paths
        if [ -e "$p" ]; then
          printf '%s\0' "$p"
        fi
      done \
    > "$list"

  local made_data=false
  if [ -s "$list" ]; then
    if tar --null -czf "$data_file" --files-from="$list"; then
      made_data=true
    else
      rm -f "$list"
      error "Failed to create data archive"
    fi
  fi
  rm -f "$list"

  if $made_data; then
    echo "{
      \"status\": \"success\",
      \"config\": \"$config_file\",
      \"data\": \"$data_file\",
      \"message\": {
        \"ru\": \"Бэкап успешно выполнен\",
        \"en\": \"Backup completed successfully\"
      }
    }"
  else
    echo "{
      \"status\": \"success\",
      \"config\": \"$config_file\",
      \"data\": null,
      \"message\": {
        \"ru\": \"Бэкап конфигурации выполнен (шар с данными не найдено, архив данных не создавался)\",
        \"en\": \"Config backup completed (no share data to archive)\"
      }
    }"
  fi
}


restore_all() {
  local backup_name="$1"

  local base_dir="/var/lib/alterator/service/service-samba-share"
  local config_dir="$base_dir/config-backup"
  local data_dir="$base_dir/data-backup"

  mkdir -p "$config_dir" "$data_dir" || error "Failed to create backup directories"

  local config_file
  local data_file

  # Find backup
  if [ -n "$backup_name" ] && [ "$backup_name" != "null" ]; then
    case "$backup_name" in
      *.conf)   backup_name="${backup_name%.conf}" ;;
      *.tar.gz) backup_name="${backup_name%.tar.gz}" ;;
    esac
    config_file="$config_dir/${backup_name}.conf"
    data_file="$data_dir/${backup_name}.tar.gz"

    [ ! -f "$config_file" ] && error "Config backup not found: $config_file"
  else
    # We take the most recent config backup.
    config_file=$(find "$config_dir" -maxdepth 1 -type f -name '*.conf' -printf '%T@ %p\n' 2>/dev/null \
                  | sort -nr | head -n1 | cut -d' ' -f2-)
    [ -z "$config_file" ] && error "There are no config backups available"

    local base_name
    base_name=$(basename "$config_file" .conf)
    data_file="$data_dir/${base_name}.tar.gz"
  fi

  # restore smb.conf
  if ! cp "$config_file" /etc/samba/smb.conf; then
    error "Failed to restore smb.conf"
  fi

  # check the configuration for validity
  if ! testparm -s /etc/samba/smb.conf >/dev/null 2>&1; then
    error "Restored smb.conf is invalid (testparm failed)"
  fi

  if ! systemctl restart smb.service; then
    error "Failed to restart Samba after restore"
  fi

  # Data recovery — only if the archive exists
  local restored_data=false
  if [ -f "$data_file" ]; then
    if tar -xzf "$data_file" -C /; then
      restored_data=true
    else
      error "Failed to restore data from archive"
    fi
  fi

  if $restored_data; then
    echo "{
      \"status\": \"restored\",
      \"config\": \"$config_file\",
      \"data\": \"$data_file\",
      \"message\": {
        \"ru\": \"Бэкап успешно восстановлен (конфиг и данные)\",
        \"en\": \"Backup successfully restored (config and data)\"
      }
    }"
  else
    echo "{
      \"status\": \"restored\",
      \"config\": \"$config_file\",
      \"data\": null,
      \"message\": {
        \"ru\": \"Восстановлен только конфиг (архив данных не найден — это нормально)\",
        \"en\": \"Restored config only (data archive not found, which is fine)\"
      }
    }"
  fi
}



# ========== MAIN SCRIPT ==========

log "---Run script---"
[ "$EUID" -ne 0 ] && error "Root required"

# reading JSON from stdin (or "{}" by timeout)
read -t 10 -r input || { log "Timeout when reading input data"; input="{}"; }
log "Input data is received: $input"

operation=$(echo "$input" | jq -r '.operation // empty')
[ -z "$operation" ] && operation="$1"


# CREATE
c_share_name=$(echo "$input" | jq -r '.create.share_name // empty')
c_share_path=$(echo "$input" | jq -r '.create.share_path // empty')
c_access_user=$(echo "$input" | jq -r '.create.access_user // empty')
c_access_type=$(echo "$input" | jq -r '.create.access_type // empty')
c_allowed_users=$(echo "$input" | jq -r '.create.allowed_users // empty')

# UPDATE
u_share_name=$(echo "$input" | jq -r '.update.share_name // empty')
u_share_path=$(echo "$input" | jq -r '.update.share_path // empty')
u_access_user=$(echo "$input" | jq -r '.update.access_user // empty')
u_access_type=$(echo "$input" | jq -r '.update.access_type // empty')
u_allowed_users=$(echo "$input" | jq -r '.update.allowed_users // empty')

# DELETE
d_share_name=$(echo "$input" | jq -r '.delete.share_name // empty')

backup_name=$(echo "$input" | jq -r '.backup_name // empty')

case "$operation" in
  create)
    # мminimal validation
    [ -z "$c_share_name"  ] && error "create.share_name is required"
    [ -z "$c_share_path"  ] && error "create.share_path is required"
    [ -z "$c_access_user" ] && error "create.access_user is required"
    [ -z "$c_access_type" ] && error "create.access_type is required"
    create_share "$c_share_name" "$c_share_path" "$c_access_user" "$c_access_type" "$c_allowed_users"
    ;;

  update)
    [ -z "$u_share_name" ] && error "update.share_name is required"
    update_share "$u_share_name" "$u_share_path" "$u_access_user" "$u_access_type" "$u_allowed_users"
    ;;

  delete)
    [ -z "$d_share_name" ] && error "delete.share_name is required"
    delete_share "$d_share_name"
    ;;

  status|"")
    status_samba_share
    ;;

  deploy)   deploy_samba_share ;;
  undeploy) undeploy_samba_share ;;
  start)    start_samba_share ;;
  stop)     stop_samba_share ;;
  backup)   backup_all "$backup_name" ;;
  restore)  restore_all "$backup_name" ;;

  *)
    error "Unknown operation: $operation"
    ;;
esac

log "The script has been successfully completed"
exit 0
